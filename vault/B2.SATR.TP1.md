---
id: t9wkuehbrl7iknmi1um2po3
title: TP1 - RTOS/ESP-IDF
desc: ''
updated: 1669820981534
created: 1669371857862
---

# Préparation du TP

Se familiariser avec :
- [FreeRTOS - Tasks and Co-Routines](https://freertos.org/taskandcr.html)

    --> API Reference > Task Creation
    - vsStackDepth
    - vTaskDelay
    - xTaskCreate
    - vTaskSuspend

- [les exemples d'esp-idf](https://github.com/espressif/esp-idf/tree/master/examples)

# Prérequis/Installations

Installer ESP-IDF et suivre le `Get Started`:
- [Repo GitHub ESP-IDF](github.com/espressif/esp-idf)
- [Docs - Get-Started: Manual Install (linux-macos)](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/linux-macos-setup.html)

> Possibilité d'utiliser VS Code

# Slide

![](/assets/images/B2.SATR.TP1.RTOSESPIDF-01.png)
![](/assets/images/B2.SATR.TP1.RTOSESPIDF-02.png)
![](/assets/images/B2.SATR.TP1.RTOSESPIDF-03.png)

## FreeRTOS

![](/assets/images/B2.SATR.TP1.RTOSESPIDF-04.png)

## ESP-IDF

![](/assets/images/B2.SATR.TP1.RTOSESPIDF-05.png)

## Hello World

![](/assets/images/B2.SATR.TP1.RTOSESPIDF-06.png)

## Generic GPIO

![](/assets/images/B2.SATR.TP1.RTOSESPIDF-07.png)


# Suppléments

## Code C

> Pour de l'embarquer le RUST est plus robuste que le C

[Le code à utiliser ici :](http://cliffle.com/blog/not-thread-safe/#the-bank-account-example)
```c++
/*
 * Stores information about a bank account.
 */
struct bank_account {
    /* How much money is in the account. */
    int balance; /* never use floats for managing money (too much approximation) */
};

/*
 * Deposits 'amt' into the 'account' and returns the new balance.
 */
int deposit(struct bank_account *account, int amt) {
    account->balance += amt;
    return account->balance;
}

/*
 * Tries to withdraw 'amt' from the account. Returns 'true' if it
 * succeeded, 'false' if the account didn't contain enough.
 */
bool withdraw(struct bank_account *account, int amt) {
    if (account->balance >= amt) {
        account->balance -= amt;
        return true;
    } else {
        return false;
    }
}
```
Remarque:
- pour connaitre l'état du compte il suffit de faire `deposit(0)` est la fct retournera ce qui reste dans le compte


## Python

```Python
def deposit(amt int) -> int
def withdraw(amt int) -> int
```


## Interruptions

### GPIO

Le code de gestion des interruptions`~/esp/generic_gpio/main/gpio_example_main.c`
```C
static QueueHandle_t gpio_evt_queue = NULL;

static void IRAM_ATTR gpio_isr_handler(void* arg)
{
    uint32_t gpio_num = (uint32_t) arg;
    xQueueSendFromISR(gpio_evt_queue, &gpio_num, NULL);
}

static void gpio_task_example(void* arg)
{
    uint32_t io_num;
    for(;;) {
        if(xQueueReceive(gpio_evt_queue, &io_num, portMAX_DELAY)) {
            printf("GPIO[%"PRIu32"] intr, val: %d\n", io_num, gpio_get_level(io_num));
        }
    }
}
```

## UART - Universal Asynchronus Receiver/Transmitter

- [lien vers la doc UART](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/uart.html)
- Un UART n'est pas un bus temps réel
    buffer entre le code et les files om gere pas ca
- Chaque UART a sa propre horloge (dans le cas d'un USRT (synchronus) on rajoute une clock de référence)
- equivalence reseau: 2eme couche du modele OSI donc similaire a une tram avec son protocle

<!--8 data graph-->
![](/assets/images/B2.SATR.TP1.RTOSESPIDF.NotesGEA-01.png)

![](/assets/images/B2.SATR.TP1.RTOSESPIDF.NotesGEA-02.png)

![](/assets/images/B2.SATR.TP1.RTOSESPIDF.NotesGEA-03.png)

ATTETNION: 
- le pc est en 64 bit mais l'ESP32 est sur du 32 bit donc la taille d'un `int` n'est pas la meme
- cepedant avec un `int` en 32 bit on peut gérer jusqu'à 40 millions d'euros i.e. $(2*32-1)/100=42\;millions$

### Messages

Ces messages devront prendre en compte :
- Header: [OxCA,OxFE,OxCA,OxFE]
- type: REQ/REP
- Client ID
- Req ID
- Operation
- Ammount (32 bit int)

Exemple:
- 1 client et 1 serveur pour le moment
- le client fait une requete:
    - `M1(type=REQ, CID=1, RID=1, Amount=100, Op=1)`
- Il recoit alors la réponse:
    - `M1(type=REP, CID=1, RID=1, Amount=200, Op=1)`
- On remarque alors qu'il peut y avoir un probleme avec ce jeu de parametres car on ne sait pas comment gérer l'absence et l'attente de réponse --> introduire du coup un param `time out` de 1 sec
- Autre soucis c'est la synchronisation des canaux --> ajouter un `HEADER`
    - une autre option aurait été de faire un `3handshake` (soit `Sync>Sync/Ack>Ack`)
- Du coup on reprend l'échange précédant avec le header, on envoit dans l'ordre :
    1. 4 oct(s): Header
    2. 1 oct(s): Type
    3. 1 oct(s): Client ID (ou mieux un **numéro de port** ! attention ceci est valide si il n'y a pas de bus commun entre les pc)
    4. 1 oct(s): Req ID 
        - ici peut etre 1 oct suffit pas mais en vrai avec 1 oct on doit avoir plus de 256 requetes non répondus en moins d'une seconde donc ça ira
    5. 1 oct(s): Operation
    6. 4 oct(s): Amount
- Une autre organisation plus optimale niveau mémoire et temps d'envoi/recpetion (mais cela rend la programmation plus risquée lors de la conception du coup on va plustot préférencer l'option précédente)
    1. 4 oct(s): Header
    2. 1 oct(s): Type + Operation
    3. 1 oct(s): Client ID
    4. 1 oct(s): Req ID
    5. 4 oct(s): Amount

Un exemple de séquence de message :
![](/assets/images/B2.SATR.TP1.RTOSESPIDF.NotesGEA-04.png)
- La configuration python avec `dep/withdraw/tx/rx` ne permettra pas d'envoyer plusieurs requetes en meme temps car les fcts `dep` et `with` appel `tx` et `rx` (si on a le temps on verra comment gerer de l'asynchrone en python)

### Files d'attentes

On crée un pointeur contenant toute les files d'attentes (`Rx`,`Tx1`, `Tx2`, `Tx3`, ...).

Chaque files nécessite une capacité (nombre de requete qu'elle contient ici 10) et d'une taille pour chaque requete
```C
//create a queue to handle gpio event from isr
    gpio_evt_queue = xQueueCreate(10, sizeof(uint32_t));
```
### Priorités

Maintenant quelles priorités données aux tâches, il y a 3 philosophies :
- Back Pressure: donner la prior. à Tx pour eviter des bottle neck
- Conservative : donner la prior. à Rx pour ne pas perdre de donner
- Fairly: donner la priorité à la tache la plus solicité ici bank puisque qu'il a 3 copie de Tx/Rx qui l'appelle

## Test Unitaire

TDD - Test Driver Development

# Compte Rendu de TP

## Hello World

1. Suivre le [guide d'installation](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/linux-macos-setup.html#) jusqu'à l'étape `Configure Your Project` (etape exclue).
2. Ignorer cette étape, mais à la place modifier le fichier `/workspace/esp/hello_world/sdkconfig` pour reconfigurer la fréquence de $40MHz$ à $26MHz$ (cf slide 6 pour plus d'info).
3. Continuer les étapes restantes du [guide d'installation](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/linux-macos-setup.html#)
    - Une fois le `Build Project` terminé, lancer le flash
    - Si vous recevez une erreur du style "port introuvalbe", s'assurer que la session utilisateur a acces au groupe
        1. `ll \dev\ttyUSB0` (ou `ll \dev\PORT`) pour connaitre les droits d'accès du port
        2. `sudo usermod -aG GROUP USERNAME` pour ajouter un user dans un groupe
        3. `groups` ne se met pas à jour directement (visuellement) donc faire `newgrp GROUP` pour mettre à jour le groupe et relancer `groups` pour lister les utilisateurs (vérifier que l'utilisateur ajouter et bien présent).

## Generic GPIO

1. Se placer dans le workspace (ici `/esp/`) et copier-coller le dossier exemple gpio `cp -r $IDF_PATH/examples/peripherals/gpio/generic_gpio .`
2. Se placer dans `/workspace/generic_gpio` et lancer `idf.py set-target esp32`
3. Modifier le fichier `/workspace/generic_gpio/sdkconfig` pour reconfigurer la fréquence de $40MHz$ à $26MHz$ (cf slide 7 pour plus d'info).
4. Lancer le build `idf.py build`
5. Flasher la carte `idf.py flash` (ou `idf.py -p PORT flash`)
6. Le code est déjà en train de s'exécuter en background pour le voir lancer `idf.py monitor` (ou `idf.py -p PORT monitor`)
7. Se familiariser avec le code de communication `/workspace/generic_gpio/main/`